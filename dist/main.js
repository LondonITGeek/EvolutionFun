!function(n){var c={};function t(i){if(c[i])return c[i].exports;var e=c[i]={i:i,l:!1,exports:{}};return n[i].call(e.exports,e,e.exports,t),e.l=!0,e.exports}t.m=n,t.c=c,t.d=function(n,c,i){t.o(n,c)||Object.defineProperty(n,c,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,c){if(1&c&&(n=t(n)),8&c)return n;if(4&c&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&c&&"string"!=typeof n)for(var e in n)t.d(i,e,function(c){return n[c]}.bind(null,e));return i},t.n=function(n){var c=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(c,"a",c),c},t.o=function(n,c){return Object.prototype.hasOwnProperty.call(n,c)},t.p="",t(t.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/creature.js\nclass Creature {\r\n  constructor(genome, neuralNetwork, startingX, startingY, dimension, gameWidth, gameHeight, speed, drawInfo) {\r\n    this.genome = genome;\r\n    this.neuralNetwork = neuralNetwork;\r\n    this.gameWidth = gameWidth;\r\n    this.gameHeight = gameHeight;\r\n    this.speed = speed;\r\n    this.drawInfo = drawInfo;\r\n    this.dimensions = {\r\n      width: dimension,\r\n      height: dimension,\r\n    };\r\n\r\n    this.position = {\r\n      x: startingX,\r\n      y: startingY,\r\n    };\r\n\r\n    this.generateColour();\r\n  }\r\n\r\n  scaleValue(value, xMin, xMax, yMin, yMax) {\r\n    var percent = (value - yMin) / (yMax - yMin);\r\n    return percent * (xMax - xMin) + xMin;\r\n  }\r\n\r\n  getRandomColour(scaledGenomeNumber) {\r\n    return `#${Math.floor(scaledGenomeNumber * 16777215).toString(16)}`;\r\n  }\r\n\r\n  generateColour() {\r\n    var genomeColour =\r\n      this.genome.chromosomes.reduce((lastValue, currentValue) => {\r\n        lastValue ^= currentValue;\r\n        return lastValue >>> 0;\r\n      }, this.genome.chromosomes[0]) >>> 0;\r\n\r\n    var scaledGenomeColour = this.scaleValue(genomeColour, 0, 1, 0, 4294967295); // Max value of unsigned 32 bit int... 4294967295\r\n    this.colour = this.getRandomColour(scaledGenomeColour);\r\n  }\r\n\r\n  drawerLable(ctx) {\r\n    ctx.fillText(`${this.genome.toString()}`, this.position.x - 10, this.position.y - 10);\r\n  }\r\n\r\n  drawer(ctx) {\r\n    ctx.fillStyle = this.colour;\r\n    ctx.beginPath();\r\n    ctx.ellipse(\r\n      this.position.x + this.dimensions.width / 2,\r\n      this.position.y + this.dimensions.height / 2,\r\n      this.dimensions.width / 2,\r\n      this.dimensions.height / 2,\r\n      0,\r\n      0,\r\n      2 * Math.PI\r\n    );\r\n    ctx.fill();\r\n    ctx.closePath();\r\n    if (this.drawInfo) {\r\n      this.drawerLable(ctx);\r\n    }\r\n  }\r\n\r\n  update(actionProbabilities) {\r\n    const currentPosition = {\r\n      ...this.position,\r\n    };\r\n\r\n    if (actionProbabilities.length > 0) {\r\n      var currentProbabilityRoll = Math.random();\r\n      var bestAction = actionProbabilities.sort((a, b) => b - a)[0];\r\n      console.log(bestAction.getValue());\r\n\r\n      if (currentProbabilityRoll < bestAction.getValue()) {\r\n        bestAction.applyAction(this);\r\n      }\r\n      if (\r\n        this.position.x < 0 ||\r\n        this.position.x >= this.gameWidth * this.dimensions.width ||\r\n        this.position.y < 0 ||\r\n        this.position.y >= this.gameHeight * this.dimensions.height\r\n      ) {\r\n        //console.log("Hit Edge");\r\n        this.position = currentPosition;\r\n      }\r\n    }\r\n  }\r\n\r\n  updateAndRedrawer(ctx) {\r\n    var actionProbabilities = this.neuralNetwork.feedForward(this);\r\n    this.update(actionProbabilities);\r\n    this.drawer(ctx);\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/game.js\nclass Game {\r\n  constructor(GAME_HEIGHT, GAME_WIDTH, DIVISION_SIZE, SHOW_GRAPH) {\r\n    this.height = GAME_HEIGHT;\r\n    this.width = GAME_WIDTH;\r\n    this.divisionSize = DIVISION_SIZE;\r\n    this.showGraph = SHOW_GRAPH;\r\n    this.gameCreatures = [];\r\n\r\n    this.canvas = document.createElement("canvas");\r\n    this.canvas.setAttribute("id", "canvas");\r\n    this.canvas.setAttribute("width", GAME_WIDTH * DIVISION_SIZE);\r\n    this.canvas.setAttribute("height", GAME_HEIGHT * DIVISION_SIZE);\r\n    this.canvas.setAttribute("style", "border: 1px solid black; box-sizing: border-box");\r\n    document.body.appendChild(this.canvas);\r\n    this.ctx = canvas.getContext("2d");\r\n  }\r\n\r\n  addCreature(creature) {\r\n    this.gameCreatures.push(creature);\r\n  }\r\n\r\n  drawGrid() {\r\n    this.ctx.lineWidth = 0.5;\r\n    // Do columns\r\n    for (let index = this.divisionSize; index < this.width * this.divisionSize; index += this.divisionSize) {\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(index, 0);\r\n      this.ctx.lineTo(index, this.height * this.divisionSize);\r\n      this.ctx.stroke();\r\n      this.ctx.closePath();\r\n    }\r\n\r\n    // Do Rows\r\n    for (let index = this.divisionSize; index < this.height * this.divisionSize; index += this.divisionSize) {\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(0, index);\r\n      this.ctx.lineTo(this.width * this.divisionSize, index);\r\n      this.ctx.stroke();\r\n      this.ctx.closePath();\r\n    }\r\n  }\r\n\r\n  update() {\r\n    this.ctx.fillStyle = "white";\r\n    this.ctx.fillRect(0, 0, this.width * this.divisionSize, this.height * this.divisionSize);\r\n    this.gameCreatures.forEach((creature) => {\r\n      creature.updateAndRedrawer(this.ctx);\r\n    });\r\n\r\n    if (this.showGraph) {\r\n      this.drawGrid();\r\n    }\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/genome.js\nclass Genome {\r\n  constructor(size) {\r\n    // array of 32 bit numbers, each is a link in the brain\r\n    this.size = size;\r\n    this.chromosomes = new Uint32Array(size);\r\n    window.crypto.getRandomValues(this.chromosomes);\r\n  }\r\n\r\n  toString() {\r\n    return this.chromosomes.join(":");\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/neuron.js\nclass Neuron {\r\n  constructor(type, game) {\r\n    this.type = type;\r\n    this.game = game;\r\n    this.connections = [];\r\n    this.lastValue = 0;\r\n  }\r\n\r\n  scaleValue(value, xMin, xMax, yMin, yMax) {\r\n    var percent = (value - yMin) / (yMax - yMin);\r\n    return percent * (xMax - xMin) + xMin;\r\n  }\r\n\r\n  addConnection(connection) {\r\n    this.connections.push(connection);\r\n  }\r\n\r\n  updateLastValue(lastValue) {\r\n    this.lastValue = lastValue;\r\n  }\r\n\r\n  getValue(creature) {\r\n    return this.lastValue;\r\n  }\r\n\r\n  applyAction(creature) {\r\n    return;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.type}`;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/inputs/SensitivityToProximityToEast.js\n\r\n\r\nclass SensitivityToProximityToEast_SensitivityToProximityToEast extends Neuron {\r\n  constructor(game) {\r\n    super("SensitivityToProximityToEast", game);\r\n  }\r\n\r\n  getValue(creature) {\r\n    var scaledGameWidth = this.game.width * this.game.divisionSize;\r\n    var scaledInput = this.scaleValue(creature.position.x, 0, 1, 0, scaledGameWidth);\r\n    return scaledInput;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/inputs/SensitivityToProximityToWest.js\n\r\n\r\nclass SensitivityToProximityToWest_SensitivityToProximityToWest extends Neuron {\r\n  constructor(game) {\r\n    super("SensitivityToProximityToWest", game);\r\n  }\r\n\r\n  getValue(creature) {\r\n    var scaledGameWidth = this.game.width * this.game.divisionSize;\r\n    var invertedX = scaledGameWidth - creature.position.x;\r\n    var scaledInput = this.scaleValue(invertedX, 0, 1, 0, scaledGameWidth);\r\n    return scaledInput;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/inputs/SensitivityToProximityToSouth.js\n\r\n\r\nclass SensitivityToProximityToSouth_SensitivityToProximityToSouth extends Neuron {\r\n  constructor(game) {\r\n    super("SensitivityToProximityToSouth", game);\r\n  }\r\n\r\n  getValue(creature) {\r\n    var scaledGameHeight = this.game.height * this.game.divisionSize;\r\n    var scaledInput = this.scaleValue(creature.position.y, 0, 1, 0, scaledGameHeight);\r\n    return scaledInput;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/inputs/SensitivityToProximityToNorth.js\n\r\n\r\nclass SensitivityToProximityToNorth_SensitivityToProximityToNorth extends Neuron {\r\n  constructor(game) {\r\n    super("SensitivityToProximityToNorth", game);\r\n  }\r\n\r\n  /*\r\n    if creature.y = 0 return 1\r\n    if creature.y = 128 return 0\r\n  */\r\n  getValue(creature) {\r\n    var scaledGameHeight = this.game.height * this.game.divisionSize;\r\n    var invertedY = scaledGameHeight - creature.position.y;\r\n    var scaledInput = this.scaleValue(invertedY, 0, 1, 0, scaledGameHeight);\r\n    return scaledInput;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/bit-operations.js\nfunction checkBit(number, bitToCheck) {\r\n  var mask = (1 << bitToCheck) >>> 0;\r\n  var result = (number & mask) >>> 0;\r\n  return result !== 0;\r\n}\r\n\r\nfunction slice(number, start, end) {\r\n  var mask = Math.pow(2, end - start + 1) - 1;\r\n  mask = mask << start;\r\n  var result = number & mask;\r\n  return result >> start;\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/connection.js\nclass Connection {\r\n  constructor(source, sink, weight) {\r\n    this.source = source;\r\n    this.sink = sink;\r\n    this.weight = weight;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.source}:${this.sink}:${this.weight}`;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoNorth.js\n\r\n\r\nclass GoNorth_GoNorth extends Neuron {\r\n  constructor() {\r\n    super("GoNorth");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.y -= creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoNorthEast.js\n\r\n\r\nclass GoNorthEast_GoNorthEast extends Neuron {\r\n  constructor() {\r\n    super("GoNorthEast");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.y -= creature.speed * creature.dimensions.width;\r\n    creature.position.x += creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoEast.js\n\r\n\r\nclass GoEast_GoEast extends Neuron {\r\n  constructor() {\r\n    super("GoEast");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.x += creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoSouthEast.js\n\r\n\r\nclass GoSouthEast_GoSouthEast extends Neuron {\r\n  constructor() {\r\n    super("GoSouthEast");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.x += creature.speed * creature.dimensions.width;\r\n    creature.position.y += creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoSouth.js\n\r\n\r\nclass GoSouth_GoSouth extends Neuron {\r\n  constructor() {\r\n    super("GoSouth");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.y += creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoSouthWest.js\n\r\n\r\nclass GoSouthWest_GoSouthWest extends Neuron {\r\n  constructor() {\r\n    super("GoSouthWest");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.y += creature.speed * creature.dimensions.width;\r\n    creature.position.x -= creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoWest.js\n\r\n\r\nclass GoWest_GoWest extends Neuron {\r\n  constructor() {\r\n    super("GoWest");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.x -= creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/GoNorthWest.js\n\r\n\r\nclass GoNorthWest_GoNorthWest extends Neuron {\r\n  constructor() {\r\n    super("GoNorthWest");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    creature.position.y -= creature.speed * creature.dimensions.width;\r\n    creature.position.x -= creature.speed * creature.dimensions.width;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/outputs/DoNothing.js\n\r\n\r\nclass DoNothing_DoNothing extends Neuron {\r\n  constructor() {\r\n    super("DoNothing");\r\n  }\r\n\r\n  applyAction(creature) {\r\n    return;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/neural-network.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass neural_network_NeuralNetwork {\r\n  constructor(numberOfHiddenNeurons, genome, sensitivityNeuronFactory) {\r\n    this.genome = genome;\r\n    this.hiddenNeurons = new Array(numberOfHiddenNeurons);\r\n\r\n    for (let index = 0; index < this.hiddenNeurons.length; index++) {\r\n      this.hiddenNeurons[index] = new Neuron(`Hidden Layer ${index}`);\r\n    }\r\n\r\n    this.inputNeurons = [\r\n      sensitivityNeuronFactory("SensitivityToProximityToEast"),\r\n      sensitivityNeuronFactory("SensitivityToProximityToNorth"),\r\n      sensitivityNeuronFactory("SensitivityToProximityToSouth"),\r\n      sensitivityNeuronFactory("SensitivityToProximityToWest"),\r\n    ];\r\n\r\n    this.outputNeurons = [\r\n      new DoNothing_DoNothing(),\r\n      new GoNorth_GoNorth(),\r\n      new GoNorthEast_GoNorthEast(),\r\n      new GoEast_GoEast(),\r\n      new GoSouthEast_GoSouthEast(),\r\n      new GoSouth_GoSouth(),\r\n      new GoSouthWest_GoSouthWest(),\r\n      new GoWest_GoWest(),\r\n      new GoNorthWest_GoNorthWest(),\r\n    ];\r\n\r\n    for (let index = 0; index < this.genome.size; index++) {\r\n      var chromosome = this.genome.chromosomes[index];\r\n      this.addConnection(chromosome);\r\n    }\r\n  }\r\n\r\n  scaleWeight(weight, xMin, xMax, yMin, yMax) {\r\n    var percent = (weight - yMin) / (yMax - yMin);\r\n    return percent * (xMax - xMin) + xMin;\r\n  }\r\n\r\n  // first bit is source type (i.e 0 = sensor neuron, or 1 hidden neuron)\r\n  // next 5 bits determine which instance of that source type we have\r\n  // next bit is the sink type (i.e an internal neuron or an action/output neuron)\r\n  // next 20 bits is the weight of the connection\r\n\r\n  //      31| 30-26 | 25| 24-20 |19-----------------0\r\n  //       1| 01110 | 0 | 11000 |10010111001011000101\r\n  //E.g.   0| 00011 | 0 | 01100 |11001100110011001100\r\n  //                             10000000000000000000\r\n  //                             11111111111111111111 = 0 to 1048575\r\n  addConnection(chromosome) {\r\n    var sourceIsAnInputNeuron = checkBit(chromosome, 31); // 0 based index on the bits, i.e. 0 is furthest right (least significant bit)\r\n    var getSourceInstance = slice(chromosome, 26, 30) % (sourceIsAnInputNeuron ? this.inputNeurons.length : this.hiddenNeurons.length);\r\n    var sinkIsAnOutputNeuron = checkBit(chromosome, 25);\r\n    var getOutputInstance = slice(chromosome, 20, 24) % (sinkIsAnOutputNeuron ? this.outputNeurons.length : this.hiddenNeurons.length);\r\n    var weight = this.scaleWeight(slice(chromosome, 0, 19), -4, 4, 0, 1048575);\r\n\r\n    var source;\r\n    var sink;\r\n\r\n    if (sourceIsAnInputNeuron) {\r\n      // get the sensor type\r\n      source = this.inputNeurons[getSourceInstance];\r\n    } else {\r\n      // this is a hidden layer neuron\r\n      source = this.hiddenNeurons[getSourceInstance];\r\n    }\r\n\r\n    if (sinkIsAnOutputNeuron) {\r\n      // get the action type\r\n      sink = this.outputNeurons[getOutputInstance];\r\n    } else {\r\n      // this is a hidden layer neuron\r\n      sink = this.hiddenNeurons[getOutputInstance];\r\n    }\r\n\r\n    sink.addConnection(new Connection(source, sink, weight));\r\n  }\r\n\r\n  feedForward(creature) {\r\n    // Only return output neurons with a positive "probability"\r\n    return this.outputNeurons.filter((n) => {\r\n      var outputForN = this.feedForwardPer(n, creature);\r\n      n.updateLastValue(outputForN);\r\n      return outputForN > 0;\r\n    });\r\n  }\r\n\r\n  feedForwardPer(neuron, creature) {\r\n    var depth = 0;\r\n\r\n    let getInput = (connection, seenNodes) => {\r\n      depth++;\r\n      if (depth > 15) {\r\n        debugger;\r\n      }\r\n      // this connection has a source and a weight, need to get the source input value * weight and return that\r\n      var sink = connection.sink;\r\n      var source = connection.source;\r\n      var weight = connection.weight;\r\n      seenNodes.set(sink, sink.getValue(creature));\r\n\r\n      if (seenNodes.has(source)) {\r\n        return seenNodes.get(source);\r\n      } else if (source.connections.length === 0) {\r\n        // we\'re at the top of the tree so return the value of the input * weight\r\n        var input = source.getValue(creature);\r\n        return input * weight;\r\n      } else {\r\n        // we still have more connections to get\r\n        var sumOfWeightedInputs = 0;\r\n        for (let index = 0; index < source.connections.length; index++) {\r\n          const connection = source.connections[index];\r\n          sumOfWeightedInputs += getInput(connection, seenNodes);\r\n        }\r\n\r\n        return Math.tanh(sumOfWeightedInputs);\r\n      }\r\n    };\r\n\r\n    var sumOfWeightedInputs = 0;\r\n    for (let index = 0; index < neuron.connections.length; index++) {\r\n      const seenNodes = new Map();\r\n      const connection = neuron.connections[index];\r\n      sumOfWeightedInputs += getInput(connection, seenNodes);\r\n    }\r\n    return Math.tanh(sumOfWeightedInputs);\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction randomNumberBetween(min, max) {\r\n  return Math.floor(Math.random() * (max - min) + 1);\r\n}\r\n\r\nfunction roundToNearest(numberToRound, valueToNearest) {\r\n  return Math.ceil(numberToRound / valueToNearest) * valueToNearest;\r\n}\r\n\r\nfunction getPositionWithin(game) {\r\n  return roundToNearest(randomNumberBetween(0, game.width * game.divisionSize - game.divisionSize), game.divisionSize);\r\n}\r\n\r\nconst src_sensitivityNeuronFactory = (game) => (type) => {\r\n  switch (type) {\r\n    case "SensitivityToProximityToEast":\r\n      return new SensitivityToProximityToEast_SensitivityToProximityToEast(game);\r\n    case "SensitivityToProximityToWest":\r\n      return new SensitivityToProximityToWest_SensitivityToProximityToWest(game);\r\n    case "SensitivityToProximityToSouth":\r\n      return new SensitivityToProximityToSouth_SensitivityToProximityToSouth(game);\r\n    case "SensitivityToProximityToNorth":\r\n      return new SensitivityToProximityToNorth_SensitivityToProximityToNorth(game);\r\n    default:\r\n      break;\r\n  }\r\n};\r\n\r\nfunction initialiseGame() {\r\n  const game = new Game(128, 128, 5, false);\r\n  for (let index = 0; index < 10; index++) {\r\n    // 0,0 to 635,635\r\n    const genome = new Genome(5);\r\n    const neuralNetwork = new neural_network_NeuralNetwork(3, genome, src_sensitivityNeuronFactory(game));\r\n    const creature = new Creature(\r\n      genome,\r\n      neuralNetwork,\r\n      getPositionWithin(game),\r\n      getPositionWithin(game),\r\n      game.divisionSize,\r\n      game.width,\r\n      game.height,\r\n      1,\r\n      false\r\n    );\r\n    game.addCreature(creature);\r\n  }\r\n\r\n  return game;\r\n}\r\n\r\nlet src_game = initialiseGame();\r\nlet framesPerSecond = 30;\r\n\r\nfunction animate() {\r\n  src_game.update();\r\n  setTimeout(() => requestAnimationFrame(animate), 1000 / framesPerSecond);\r\n}\r\n\r\nanimate();\r\n\r\n// var n = new Genome(4);\r\n// n.toString();\r\n\r\n// var nn = new NeuralNetwork(2);\r\n// for (let index = 0; index < 4; index++) {\r\n//   var connection = nn.getConnection(n.chromosomes[index]);\r\n//   console.log(connection.toString());\r\n// }\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3JlYXR1cmUuanM/MDE0YyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS5qcz83ZGUwIiwid2VicGFjazovLy8uL3NyYy9nZW5vbWUuanM/ZGZjNSIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vbmV1cm9uLmpzP2VlNDciLCJ3ZWJwYWNrOi8vLy4vc3JjL25uL2lucHV0cy9TZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0LmpzPzI1NDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL25uL2lucHV0cy9TZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0LmpzP2I2NWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL25uL2lucHV0cy9TZW5zaXRpdml0eVRvUHJveGltaXR5VG9Tb3V0aC5qcz81NjdjIiwid2VicGFjazovLy8uL3NyYy9ubi9pbnB1dHMvU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvTm9ydGguanM/ZTJjZiIsIndlYnBhY2s6Ly8vLi9zcmMvYml0LW9wZXJhdGlvbnMuanM/YjBlZiIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vY29ubmVjdGlvbi5qcz9iMjc0Iiwid2VicGFjazovLy8uL3NyYy9ubi9vdXRwdXRzL0dvTm9ydGguanM/MmZhZCIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vb3V0cHV0cy9Hb05vcnRoRWFzdC5qcz8zZDBmIiwid2VicGFjazovLy8uL3NyYy9ubi9vdXRwdXRzL0dvRWFzdC5qcz80NWQxIiwid2VicGFjazovLy8uL3NyYy9ubi9vdXRwdXRzL0dvU291dGhFYXN0LmpzP2VhYjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL25uL291dHB1dHMvR29Tb3V0aC5qcz85OTRkIiwid2VicGFjazovLy8uL3NyYy9ubi9vdXRwdXRzL0dvU291dGhXZXN0LmpzP2JlYTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25uL291dHB1dHMvR29XZXN0LmpzPzY2MTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL25uL291dHB1dHMvR29Ob3J0aFdlc3QuanM/ODY4MiIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vb3V0cHV0cy9Eb05vdGhpbmcuanM/ZjUxZSIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vbmV1cmFsLW5ldHdvcmsuanM/MDU0OCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsdURBQXVEO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGdGQUFnRjtBQUNoRjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlGZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBd0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHlDQUF5QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFD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QVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxRQUFJO0FBQ1I7O0FBRUE7QUFDQSxFQUFFLFFBQUk7QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWF0dXJlIHtcclxuICBjb25zdHJ1Y3RvcihnZW5vbWUsIG5ldXJhbE5ldHdvcmssIHN0YXJ0aW5nWCwgc3RhcnRpbmdZLCBkaW1lbnNpb24sIGdhbWVXaWR0aCwgZ2FtZUhlaWdodCwgc3BlZWQsIGRyYXdJbmZvKSB7XHJcbiAgICB0aGlzLmdlbm9tZSA9IGdlbm9tZTtcclxuICAgIHRoaXMubmV1cmFsTmV0d29yayA9IG5ldXJhbE5ldHdvcms7XHJcbiAgICB0aGlzLmdhbWVXaWR0aCA9IGdhbWVXaWR0aDtcclxuICAgIHRoaXMuZ2FtZUhlaWdodCA9IGdhbWVIZWlnaHQ7XHJcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XHJcbiAgICB0aGlzLmRyYXdJbmZvID0gZHJhd0luZm87XHJcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB7XHJcbiAgICAgIHdpZHRoOiBkaW1lbnNpb24sXHJcbiAgICAgIGhlaWdodDogZGltZW5zaW9uLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uID0ge1xyXG4gICAgICB4OiBzdGFydGluZ1gsXHJcbiAgICAgIHk6IHN0YXJ0aW5nWSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZW5lcmF0ZUNvbG91cigpO1xyXG4gIH1cclxuXHJcbiAgc2NhbGVWYWx1ZSh2YWx1ZSwgeE1pbiwgeE1heCwgeU1pbiwgeU1heCkge1xyXG4gICAgdmFyIHBlcmNlbnQgPSAodmFsdWUgLSB5TWluKSAvICh5TWF4IC0geU1pbik7XHJcbiAgICByZXR1cm4gcGVyY2VudCAqICh4TWF4IC0geE1pbikgKyB4TWluO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmFuZG9tQ29sb3VyKHNjYWxlZEdlbm9tZU51bWJlcikge1xyXG4gICAgcmV0dXJuIGAjJHtNYXRoLmZsb29yKHNjYWxlZEdlbm9tZU51bWJlciAqIDE2Nzc3MjE1KS50b1N0cmluZygxNil9YDtcclxuICB9XHJcblxyXG4gIGdlbmVyYXRlQ29sb3VyKCkge1xyXG4gICAgdmFyIGdlbm9tZUNvbG91ciA9XHJcbiAgICAgIHRoaXMuZ2Vub21lLmNocm9tb3NvbWVzLnJlZHVjZSgobGFzdFZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHtcclxuICAgICAgICBsYXN0VmFsdWUgXj0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgIHJldHVybiBsYXN0VmFsdWUgPj4+IDA7XHJcbiAgICAgIH0sIHRoaXMuZ2Vub21lLmNocm9tb3NvbWVzWzBdKSA+Pj4gMDtcclxuXHJcbiAgICB2YXIgc2NhbGVkR2Vub21lQ29sb3VyID0gdGhpcy5zY2FsZVZhbHVlKGdlbm9tZUNvbG91ciwgMCwgMSwgMCwgNDI5NDk2NzI5NSk7IC8vIE1heCB2YWx1ZSBvZiB1bnNpZ25lZCAzMiBiaXQgaW50Li4uIDQyOTQ5NjcyOTVcclxuICAgIHRoaXMuY29sb3VyID0gdGhpcy5nZXRSYW5kb21Db2xvdXIoc2NhbGVkR2Vub21lQ29sb3VyKTtcclxuICB9XHJcblxyXG4gIGRyYXdlckxhYmxlKGN0eCkge1xyXG4gICAgY3R4LmZpbGxUZXh0KGAke3RoaXMuZ2Vub21lLnRvU3RyaW5nKCl9YCwgdGhpcy5wb3NpdGlvbi54IC0gMTAsIHRoaXMucG9zaXRpb24ueSAtIDEwKTtcclxuICB9XHJcblxyXG4gIGRyYXdlcihjdHgpIHtcclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG91cjtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5lbGxpcHNlKFxyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggKyB0aGlzLmRpbWVuc2lvbnMud2lkdGggLyAyLFxyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0IC8gMixcclxuICAgICAgdGhpcy5kaW1lbnNpb25zLndpZHRoIC8gMixcclxuICAgICAgdGhpcy5kaW1lbnNpb25zLmhlaWdodCAvIDIsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDIgKiBNYXRoLlBJXHJcbiAgICApO1xyXG4gICAgY3R4LmZpbGwoKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGlmICh0aGlzLmRyYXdJbmZvKSB7XHJcbiAgICAgIHRoaXMuZHJhd2VyTGFibGUoY3R4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZShhY3Rpb25Qcm9iYWJpbGl0aWVzKSB7XHJcbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB7XHJcbiAgICAgIC4uLnRoaXMucG9zaXRpb24sXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChhY3Rpb25Qcm9iYWJpbGl0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdmFyIGN1cnJlbnRQcm9iYWJpbGl0eVJvbGwgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICB2YXIgYmVzdEFjdGlvbiA9IGFjdGlvblByb2JhYmlsaXRpZXMuc29ydCgoYSwgYikgPT4gYiAtIGEpWzBdO1xyXG4gICAgICBjb25zb2xlLmxvZyhiZXN0QWN0aW9uLmdldFZhbHVlKCkpO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnRQcm9iYWJpbGl0eVJvbGwgPCBiZXN0QWN0aW9uLmdldFZhbHVlKCkpIHtcclxuICAgICAgICBiZXN0QWN0aW9uLmFwcGx5QWN0aW9uKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPCAwIHx8XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID49IHRoaXMuZ2FtZVdpZHRoICogdGhpcy5kaW1lbnNpb25zLndpZHRoIHx8XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55IDwgMCB8fFxyXG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA+PSB0aGlzLmdhbWVIZWlnaHQgKiB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0XHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJIaXQgRWRnZVwiKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVBbmRSZWRyYXdlcihjdHgpIHtcclxuICAgIHZhciBhY3Rpb25Qcm9iYWJpbGl0aWVzID0gdGhpcy5uZXVyYWxOZXR3b3JrLmZlZWRGb3J3YXJkKHRoaXMpO1xyXG4gICAgdGhpcy51cGRhdGUoYWN0aW9uUHJvYmFiaWxpdGllcyk7XHJcbiAgICB0aGlzLmRyYXdlcihjdHgpO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcclxuICBjb25zdHJ1Y3RvcihHQU1FX0hFSUdIVCwgR0FNRV9XSURUSCwgRElWSVNJT05fU0laRSwgU0hPV19HUkFQSCkge1xyXG4gICAgdGhpcy5oZWlnaHQgPSBHQU1FX0hFSUdIVDtcclxuICAgIHRoaXMud2lkdGggPSBHQU1FX1dJRFRIO1xyXG4gICAgdGhpcy5kaXZpc2lvblNpemUgPSBESVZJU0lPTl9TSVpFO1xyXG4gICAgdGhpcy5zaG93R3JhcGggPSBTSE9XX0dSQVBIO1xyXG4gICAgdGhpcy5nYW1lQ3JlYXR1cmVzID0gW107XHJcblxyXG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJjYW52YXNcIik7XHJcbiAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBHQU1FX1dJRFRIICogRElWSVNJT05fU0laRSk7XHJcbiAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgR0FNRV9IRUlHSFQgKiBESVZJU0lPTl9TSVpFKTtcclxuICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiYm9yZGVyOiAxcHggc29saWQgYmxhY2s7IGJveC1zaXppbmc6IGJvcmRlci1ib3hcIik7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcclxuICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICB9XHJcblxyXG4gIGFkZENyZWF0dXJlKGNyZWF0dXJlKSB7XHJcbiAgICB0aGlzLmdhbWVDcmVhdHVyZXMucHVzaChjcmVhdHVyZSk7XHJcbiAgfVxyXG5cclxuICBkcmF3R3JpZCgpIHtcclxuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDAuNTtcclxuICAgIC8vIERvIGNvbHVtbnNcclxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5kaXZpc2lvblNpemU7IGluZGV4IDwgdGhpcy53aWR0aCAqIHRoaXMuZGl2aXNpb25TaXplOyBpbmRleCArPSB0aGlzLmRpdmlzaW9uU2l6ZSkge1xyXG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgdGhpcy5jdHgubW92ZVRvKGluZGV4LCAwKTtcclxuICAgICAgdGhpcy5jdHgubGluZVRvKGluZGV4LCB0aGlzLmhlaWdodCAqIHRoaXMuZGl2aXNpb25TaXplKTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIFJvd3NcclxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5kaXZpc2lvblNpemU7IGluZGV4IDwgdGhpcy5oZWlnaHQgKiB0aGlzLmRpdmlzaW9uU2l6ZTsgaW5kZXggKz0gdGhpcy5kaXZpc2lvblNpemUpIHtcclxuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCBpbmRleCk7XHJcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLndpZHRoICogdGhpcy5kaXZpc2lvblNpemUsIGluZGV4KTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMuZGl2aXNpb25TaXplLCB0aGlzLmhlaWdodCAqIHRoaXMuZGl2aXNpb25TaXplKTtcclxuICAgIHRoaXMuZ2FtZUNyZWF0dXJlcy5mb3JFYWNoKChjcmVhdHVyZSkgPT4ge1xyXG4gICAgICBjcmVhdHVyZS51cGRhdGVBbmRSZWRyYXdlcih0aGlzLmN0eCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5zaG93R3JhcGgpIHtcclxuICAgICAgdGhpcy5kcmF3R3JpZCgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHZW5vbWUge1xyXG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcclxuICAgIC8vIGFycmF5IG9mIDMyIGJpdCBudW1iZXJzLCBlYWNoIGlzIGEgbGluayBpbiB0aGUgYnJhaW5cclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICB0aGlzLmNocm9tb3NvbWVzID0gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xyXG4gICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXModGhpcy5jaHJvbW9zb21lcyk7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLmNocm9tb3NvbWVzLmpvaW4oXCI6XCIpO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBOZXVyb24ge1xyXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGdhbWUpIHtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5sYXN0VmFsdWUgPSAwO1xyXG4gIH1cclxuXHJcbiAgc2NhbGVWYWx1ZSh2YWx1ZSwgeE1pbiwgeE1heCwgeU1pbiwgeU1heCkge1xyXG4gICAgdmFyIHBlcmNlbnQgPSAodmFsdWUgLSB5TWluKSAvICh5TWF4IC0geU1pbik7XHJcbiAgICByZXR1cm4gcGVyY2VudCAqICh4TWF4IC0geE1pbikgKyB4TWluO1xyXG4gIH1cclxuXHJcbiAgYWRkQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVMYXN0VmFsdWUobGFzdFZhbHVlKSB7XHJcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IGxhc3RWYWx1ZTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKGNyZWF0dXJlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XHJcbiAgfVxyXG5cclxuICBhcHBseUFjdGlvbihjcmVhdHVyZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy50eXBlfWA7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOZXVyb24gZnJvbSBcIi4uL25ldXJvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvRWFzdCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoZ2FtZSkge1xyXG4gICAgc3VwZXIoXCJTZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0XCIsIGdhbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoY3JlYXR1cmUpIHtcclxuICAgIHZhciBzY2FsZWRHYW1lV2lkdGggPSB0aGlzLmdhbWUud2lkdGggKiB0aGlzLmdhbWUuZGl2aXNpb25TaXplO1xyXG4gICAgdmFyIHNjYWxlZElucHV0ID0gdGhpcy5zY2FsZVZhbHVlKGNyZWF0dXJlLnBvc2l0aW9uLngsIDAsIDEsIDAsIHNjYWxlZEdhbWVXaWR0aCk7XHJcbiAgICByZXR1cm4gc2NhbGVkSW5wdXQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOZXVyb24gZnJvbSBcIi4uL25ldXJvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvV2VzdCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoZ2FtZSkge1xyXG4gICAgc3VwZXIoXCJTZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0XCIsIGdhbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoY3JlYXR1cmUpIHtcclxuICAgIHZhciBzY2FsZWRHYW1lV2lkdGggPSB0aGlzLmdhbWUud2lkdGggKiB0aGlzLmdhbWUuZGl2aXNpb25TaXplO1xyXG4gICAgdmFyIGludmVydGVkWCA9IHNjYWxlZEdhbWVXaWR0aCAtIGNyZWF0dXJlLnBvc2l0aW9uLng7XHJcbiAgICB2YXIgc2NhbGVkSW5wdXQgPSB0aGlzLnNjYWxlVmFsdWUoaW52ZXJ0ZWRYLCAwLCAxLCAwLCBzY2FsZWRHYW1lV2lkdGgpO1xyXG4gICAgcmV0dXJuIHNjYWxlZElucHV0O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTmV1cm9uIGZyb20gXCIuLi9uZXVyb25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1NvdXRoIGV4dGVuZHMgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcihnYW1lKSB7XHJcbiAgICBzdXBlcihcIlNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1NvdXRoXCIsIGdhbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoY3JlYXR1cmUpIHtcclxuICAgIHZhciBzY2FsZWRHYW1lSGVpZ2h0ID0gdGhpcy5nYW1lLmhlaWdodCAqIHRoaXMuZ2FtZS5kaXZpc2lvblNpemU7XHJcbiAgICB2YXIgc2NhbGVkSW5wdXQgPSB0aGlzLnNjYWxlVmFsdWUoY3JlYXR1cmUucG9zaXRpb24ueSwgMCwgMSwgMCwgc2NhbGVkR2FtZUhlaWdodCk7XHJcbiAgICByZXR1cm4gc2NhbGVkSW5wdXQ7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOZXVyb24gZnJvbSBcIi4uL25ldXJvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvTm9ydGggZXh0ZW5kcyBOZXVyb24ge1xyXG4gIGNvbnN0cnVjdG9yKGdhbWUpIHtcclxuICAgIHN1cGVyKFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvTm9ydGhcIiwgZ2FtZSk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAgaWYgY3JlYXR1cmUueSA9IDAgcmV0dXJuIDFcclxuICAgIGlmIGNyZWF0dXJlLnkgPSAxMjggcmV0dXJuIDBcclxuICAqL1xyXG4gIGdldFZhbHVlKGNyZWF0dXJlKSB7XHJcbiAgICB2YXIgc2NhbGVkR2FtZUhlaWdodCA9IHRoaXMuZ2FtZS5oZWlnaHQgKiB0aGlzLmdhbWUuZGl2aXNpb25TaXplO1xyXG4gICAgdmFyIGludmVydGVkWSA9IHNjYWxlZEdhbWVIZWlnaHQgLSBjcmVhdHVyZS5wb3NpdGlvbi55O1xyXG4gICAgdmFyIHNjYWxlZElucHV0ID0gdGhpcy5zY2FsZVZhbHVlKGludmVydGVkWSwgMCwgMSwgMCwgc2NhbGVkR2FtZUhlaWdodCk7XHJcbiAgICByZXR1cm4gc2NhbGVkSW5wdXQ7XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBjaGVja0JpdChudW1iZXIsIGJpdFRvQ2hlY2spIHtcclxuICB2YXIgbWFzayA9ICgxIDw8IGJpdFRvQ2hlY2spID4+PiAwO1xyXG4gIHZhciByZXN1bHQgPSAobnVtYmVyICYgbWFzaykgPj4+IDA7XHJcbiAgcmV0dXJuIHJlc3VsdCAhPT0gMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKG51bWJlciwgc3RhcnQsIGVuZCkge1xyXG4gIHZhciBtYXNrID0gTWF0aC5wb3coMiwgZW5kIC0gc3RhcnQgKyAxKSAtIDE7XHJcbiAgbWFzayA9IG1hc2sgPDwgc3RhcnQ7XHJcbiAgdmFyIHJlc3VsdCA9IG51bWJlciAmIG1hc2s7XHJcbiAgcmV0dXJuIHJlc3VsdCA+PiBzdGFydDtcclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0aW9uIHtcclxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNpbmssIHdlaWdodCkge1xyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB0aGlzLnNpbmsgPSBzaW5rO1xyXG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBgJHt0aGlzLnNvdXJjZX06JHt0aGlzLnNpbmt9OiR7dGhpcy53ZWlnaHR9YDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE5ldXJvbiBmcm9tIFwiLi4vbmV1cm9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgR29Ob3J0aCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvTm9ydGhcIik7XHJcbiAgfVxyXG5cclxuICBhcHBseUFjdGlvbihjcmVhdHVyZSkge1xyXG4gICAgY3JlYXR1cmUucG9zaXRpb24ueSAtPSBjcmVhdHVyZS5zcGVlZCAqIGNyZWF0dXJlLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOZXVyb24gZnJvbSBcIi4uL25ldXJvblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdvTm9ydGhFYXN0IGV4dGVuZHMgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiR29Ob3J0aEVhc3RcIik7XHJcbiAgfVxyXG5cclxuICBhcHBseUFjdGlvbihjcmVhdHVyZSkge1xyXG4gICAgY3JlYXR1cmUucG9zaXRpb24ueSAtPSBjcmVhdHVyZS5zcGVlZCAqIGNyZWF0dXJlLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgICBjcmVhdHVyZS5wb3NpdGlvbi54ICs9IGNyZWF0dXJlLnNwZWVkICogY3JlYXR1cmUuZGltZW5zaW9ucy53aWR0aDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE5ldXJvbiBmcm9tIFwiLi4vbmV1cm9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgR29FYXN0IGV4dGVuZHMgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiR29FYXN0XCIpO1xyXG4gIH1cclxuXHJcbiAgYXBwbHlBY3Rpb24oY3JlYXR1cmUpIHtcclxuICAgIGNyZWF0dXJlLnBvc2l0aW9uLnggKz0gY3JlYXR1cmUuc3BlZWQgKiBjcmVhdHVyZS5kaW1lbnNpb25zLndpZHRoO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTmV1cm9uIGZyb20gXCIuLi9uZXVyb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBHb1NvdXRoRWFzdCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvU291dGhFYXN0XCIpO1xyXG4gIH1cclxuXHJcbiAgYXBwbHlBY3Rpb24oY3JlYXR1cmUpIHtcclxuICAgIGNyZWF0dXJlLnBvc2l0aW9uLnggKz0gY3JlYXR1cmUuc3BlZWQgKiBjcmVhdHVyZS5kaW1lbnNpb25zLndpZHRoO1xyXG4gICAgY3JlYXR1cmUucG9zaXRpb24ueSArPSBjcmVhdHVyZS5zcGVlZCAqIGNyZWF0dXJlLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOZXVyb24gZnJvbSBcIi4uL25ldXJvblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdvU291dGggZXh0ZW5kcyBOZXVyb24ge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJHb1NvdXRoXCIpO1xyXG4gIH1cclxuXHJcbiAgYXBwbHlBY3Rpb24oY3JlYXR1cmUpIHtcclxuICAgIGNyZWF0dXJlLnBvc2l0aW9uLnkgKz0gY3JlYXR1cmUuc3BlZWQgKiBjcmVhdHVyZS5kaW1lbnNpb25zLndpZHRoO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTmV1cm9uIGZyb20gXCIuLi9uZXVyb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBHb1NvdXRoV2VzdCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvU291dGhXZXN0XCIpO1xyXG4gIH1cclxuXHJcbiAgYXBwbHlBY3Rpb24oY3JlYXR1cmUpIHtcclxuICAgIGNyZWF0dXJlLnBvc2l0aW9uLnkgKz0gY3JlYXR1cmUuc3BlZWQgKiBjcmVhdHVyZS5kaW1lbnNpb25zLndpZHRoO1xyXG4gICAgY3JlYXR1cmUucG9zaXRpb24ueCAtPSBjcmVhdHVyZS5zcGVlZCAqIGNyZWF0dXJlLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBOZXVyb24gZnJvbSBcIi4uL25ldXJvblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdvV2VzdCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvV2VzdFwiKTtcclxuICB9XHJcblxyXG4gIGFwcGx5QWN0aW9uKGNyZWF0dXJlKSB7XHJcbiAgICBjcmVhdHVyZS5wb3NpdGlvbi54IC09IGNyZWF0dXJlLnNwZWVkICogY3JlYXR1cmUuZGltZW5zaW9ucy53aWR0aDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IE5ldXJvbiBmcm9tIFwiLi4vbmV1cm9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgR29Ob3J0aFdlc3QgZXh0ZW5kcyBOZXVyb24ge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJHb05vcnRoV2VzdFwiKTtcclxuICB9XHJcblxyXG4gIGFwcGx5QWN0aW9uKGNyZWF0dXJlKSB7XHJcbiAgICBjcmVhdHVyZS5wb3NpdGlvbi55IC09IGNyZWF0dXJlLnNwZWVkICogY3JlYXR1cmUuZGltZW5zaW9ucy53aWR0aDtcclxuICAgIGNyZWF0dXJlLnBvc2l0aW9uLnggLT0gY3JlYXR1cmUuc3BlZWQgKiBjcmVhdHVyZS5kaW1lbnNpb25zLndpZHRoO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgTmV1cm9uIGZyb20gXCIuLi9uZXVyb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBEb05vdGhpbmcgZXh0ZW5kcyBOZXVyb24ge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJEb05vdGhpbmdcIik7XHJcbiAgfVxyXG5cclxuICBhcHBseUFjdGlvbihjcmVhdHVyZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjaGVja0JpdCwgc2xpY2UgfSBmcm9tIFwiLi4vYml0LW9wZXJhdGlvbnNcIjtcclxuaW1wb3J0IENvbm5lY3Rpb24gZnJvbSBcIi4vY29ubmVjdGlvblwiO1xyXG5pbXBvcnQgTmV1cm9uIGZyb20gXCIuL25ldXJvblwiO1xyXG5pbXBvcnQgeyBHb05vcnRoIH0gZnJvbSBcIi4vb3V0cHV0cy9Hb05vcnRoXCI7XHJcbmltcG9ydCB7IEdvTm9ydGhFYXN0IH0gZnJvbSBcIi4vb3V0cHV0cy9Hb05vcnRoRWFzdFwiO1xyXG5pbXBvcnQgeyBHb0Vhc3QgfSBmcm9tIFwiLi9vdXRwdXRzL0dvRWFzdFwiO1xyXG5pbXBvcnQgeyBHb1NvdXRoRWFzdCB9IGZyb20gXCIuL291dHB1dHMvR29Tb3V0aEVhc3RcIjtcclxuaW1wb3J0IHsgR29Tb3V0aCB9IGZyb20gXCIuL291dHB1dHMvR29Tb3V0aFwiO1xyXG5pbXBvcnQgeyBHb1NvdXRoV2VzdCB9IGZyb20gXCIuL291dHB1dHMvR29Tb3V0aFdlc3RcIjtcclxuaW1wb3J0IHsgR29XZXN0IH0gZnJvbSBcIi4vb3V0cHV0cy9Hb1dlc3RcIjtcclxuaW1wb3J0IHsgR29Ob3J0aFdlc3QgfSBmcm9tIFwiLi9vdXRwdXRzL0dvTm9ydGhXZXN0XCI7XHJcbmltcG9ydCB7IERvTm90aGluZyB9IGZyb20gXCIuL291dHB1dHMvRG9Ob3RoaW5nXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXVyYWxOZXR3b3JrIHtcclxuICBjb25zdHJ1Y3RvcihudW1iZXJPZkhpZGRlbk5ldXJvbnMsIGdlbm9tZSwgc2Vuc2l0aXZpdHlOZXVyb25GYWN0b3J5KSB7XHJcbiAgICB0aGlzLmdlbm9tZSA9IGdlbm9tZTtcclxuICAgIHRoaXMuaGlkZGVuTmV1cm9ucyA9IG5ldyBBcnJheShudW1iZXJPZkhpZGRlbk5ldXJvbnMpO1xyXG5cclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmhpZGRlbk5ldXJvbnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHRoaXMuaGlkZGVuTmV1cm9uc1tpbmRleF0gPSBuZXcgTmV1cm9uKGBIaWRkZW4gTGF5ZXIgJHtpbmRleH1gKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmlucHV0TmV1cm9ucyA9IFtcclxuICAgICAgc2Vuc2l0aXZpdHlOZXVyb25GYWN0b3J5KFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvRWFzdFwiKSxcclxuICAgICAgc2Vuc2l0aXZpdHlOZXVyb25GYWN0b3J5KFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvTm9ydGhcIiksXHJcbiAgICAgIHNlbnNpdGl2aXR5TmV1cm9uRmFjdG9yeShcIlNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1NvdXRoXCIpLFxyXG4gICAgICBzZW5zaXRpdml0eU5ldXJvbkZhY3RvcnkoXCJTZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0XCIpLFxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLm91dHB1dE5ldXJvbnMgPSBbXHJcbiAgICAgIG5ldyBEb05vdGhpbmcoKSxcclxuICAgICAgbmV3IEdvTm9ydGgoKSxcclxuICAgICAgbmV3IEdvTm9ydGhFYXN0KCksXHJcbiAgICAgIG5ldyBHb0Vhc3QoKSxcclxuICAgICAgbmV3IEdvU291dGhFYXN0KCksXHJcbiAgICAgIG5ldyBHb1NvdXRoKCksXHJcbiAgICAgIG5ldyBHb1NvdXRoV2VzdCgpLFxyXG4gICAgICBuZXcgR29XZXN0KCksXHJcbiAgICAgIG5ldyBHb05vcnRoV2VzdCgpLFxyXG4gICAgXTtcclxuXHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5nZW5vbWUuc2l6ZTsgaW5kZXgrKykge1xyXG4gICAgICB2YXIgY2hyb21vc29tZSA9IHRoaXMuZ2Vub21lLmNocm9tb3NvbWVzW2luZGV4XTtcclxuICAgICAgdGhpcy5hZGRDb25uZWN0aW9uKGNocm9tb3NvbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2NhbGVXZWlnaHQod2VpZ2h0LCB4TWluLCB4TWF4LCB5TWluLCB5TWF4KSB7XHJcbiAgICB2YXIgcGVyY2VudCA9ICh3ZWlnaHQgLSB5TWluKSAvICh5TWF4IC0geU1pbik7XHJcbiAgICByZXR1cm4gcGVyY2VudCAqICh4TWF4IC0geE1pbikgKyB4TWluO1xyXG4gIH1cclxuXHJcbiAgLy8gZmlyc3QgYml0IGlzIHNvdXJjZSB0eXBlIChpLmUgMCA9IHNlbnNvciBuZXVyb24sIG9yIDEgaGlkZGVuIG5ldXJvbilcclxuICAvLyBuZXh0IDUgYml0cyBkZXRlcm1pbmUgd2hpY2ggaW5zdGFuY2Ugb2YgdGhhdCBzb3VyY2UgdHlwZSB3ZSBoYXZlXHJcbiAgLy8gbmV4dCBiaXQgaXMgdGhlIHNpbmsgdHlwZSAoaS5lIGFuIGludGVybmFsIG5ldXJvbiBvciBhbiBhY3Rpb24vb3V0cHV0IG5ldXJvbilcclxuICAvLyBuZXh0IDIwIGJpdHMgaXMgdGhlIHdlaWdodCBvZiB0aGUgY29ubmVjdGlvblxyXG5cclxuICAvLyAgICAgIDMxfCAzMC0yNiB8IDI1fCAyNC0yMCB8MTktLS0tLS0tLS0tLS0tLS0tLTBcclxuICAvLyAgICAgICAxfCAwMTExMCB8IDAgfCAxMTAwMCB8MTAwMTAxMTEwMDEwMTEwMDAxMDFcclxuICAvL0UuZy4gICAwfCAwMDAxMSB8IDAgfCAwMTEwMCB8MTEwMDExMDAxMTAwMTEwMDExMDBcclxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwMDAwMDAwMDAwMDAwMDAwMDBcclxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMTExMTExMTExMTEgPSAwIHRvIDEwNDg1NzVcclxuICBhZGRDb25uZWN0aW9uKGNocm9tb3NvbWUpIHtcclxuICAgIHZhciBzb3VyY2VJc0FuSW5wdXROZXVyb24gPSBjaGVja0JpdChjaHJvbW9zb21lLCAzMSk7IC8vIDAgYmFzZWQgaW5kZXggb24gdGhlIGJpdHMsIGkuZS4gMCBpcyBmdXJ0aGVzdCByaWdodCAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KVxyXG4gICAgdmFyIGdldFNvdXJjZUluc3RhbmNlID0gc2xpY2UoY2hyb21vc29tZSwgMjYsIDMwKSAlIChzb3VyY2VJc0FuSW5wdXROZXVyb24gPyB0aGlzLmlucHV0TmV1cm9ucy5sZW5ndGggOiB0aGlzLmhpZGRlbk5ldXJvbnMubGVuZ3RoKTtcclxuICAgIHZhciBzaW5rSXNBbk91dHB1dE5ldXJvbiA9IGNoZWNrQml0KGNocm9tb3NvbWUsIDI1KTtcclxuICAgIHZhciBnZXRPdXRwdXRJbnN0YW5jZSA9IHNsaWNlKGNocm9tb3NvbWUsIDIwLCAyNCkgJSAoc2lua0lzQW5PdXRwdXROZXVyb24gPyB0aGlzLm91dHB1dE5ldXJvbnMubGVuZ3RoIDogdGhpcy5oaWRkZW5OZXVyb25zLmxlbmd0aCk7XHJcbiAgICB2YXIgd2VpZ2h0ID0gdGhpcy5zY2FsZVdlaWdodChzbGljZShjaHJvbW9zb21lLCAwLCAxOSksIC00LCA0LCAwLCAxMDQ4NTc1KTtcclxuXHJcbiAgICB2YXIgc291cmNlO1xyXG4gICAgdmFyIHNpbms7XHJcblxyXG4gICAgaWYgKHNvdXJjZUlzQW5JbnB1dE5ldXJvbikge1xyXG4gICAgICAvLyBnZXQgdGhlIHNlbnNvciB0eXBlXHJcbiAgICAgIHNvdXJjZSA9IHRoaXMuaW5wdXROZXVyb25zW2dldFNvdXJjZUluc3RhbmNlXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHRoaXMgaXMgYSBoaWRkZW4gbGF5ZXIgbmV1cm9uXHJcbiAgICAgIHNvdXJjZSA9IHRoaXMuaGlkZGVuTmV1cm9uc1tnZXRTb3VyY2VJbnN0YW5jZV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNpbmtJc0FuT3V0cHV0TmV1cm9uKSB7XHJcbiAgICAgIC8vIGdldCB0aGUgYWN0aW9uIHR5cGVcclxuICAgICAgc2luayA9IHRoaXMub3V0cHV0TmV1cm9uc1tnZXRPdXRwdXRJbnN0YW5jZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0aGlzIGlzIGEgaGlkZGVuIGxheWVyIG5ldXJvblxyXG4gICAgICBzaW5rID0gdGhpcy5oaWRkZW5OZXVyb25zW2dldE91dHB1dEluc3RhbmNlXTtcclxuICAgIH1cclxuXHJcbiAgICBzaW5rLmFkZENvbm5lY3Rpb24obmV3IENvbm5lY3Rpb24oc291cmNlLCBzaW5rLCB3ZWlnaHQpKTtcclxuICB9XHJcblxyXG4gIGZlZWRGb3J3YXJkKGNyZWF0dXJlKSB7XHJcbiAgICAvLyBPbmx5IHJldHVybiBvdXRwdXQgbmV1cm9ucyB3aXRoIGEgcG9zaXRpdmUgXCJwcm9iYWJpbGl0eVwiXHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXROZXVyb25zLmZpbHRlcigobikgPT4ge1xyXG4gICAgICB2YXIgb3V0cHV0Rm9yTiA9IHRoaXMuZmVlZEZvcndhcmRQZXIobiwgY3JlYXR1cmUpO1xyXG4gICAgICBuLnVwZGF0ZUxhc3RWYWx1ZShvdXRwdXRGb3JOKTtcclxuICAgICAgcmV0dXJuIG91dHB1dEZvck4gPiAwO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmZWVkRm9yd2FyZFBlcihuZXVyb24sIGNyZWF0dXJlKSB7XHJcbiAgICB2YXIgZGVwdGggPSAwO1xyXG5cclxuICAgIGxldCBnZXRJbnB1dCA9IChjb25uZWN0aW9uLCBzZWVuTm9kZXMpID0+IHtcclxuICAgICAgZGVwdGgrKztcclxuICAgICAgaWYgKGRlcHRoID4gMTUpIHtcclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgfVxyXG4gICAgICAvLyB0aGlzIGNvbm5lY3Rpb24gaGFzIGEgc291cmNlIGFuZCBhIHdlaWdodCwgbmVlZCB0byBnZXQgdGhlIHNvdXJjZSBpbnB1dCB2YWx1ZSAqIHdlaWdodCBhbmQgcmV0dXJuIHRoYXRcclxuICAgICAgdmFyIHNpbmsgPSBjb25uZWN0aW9uLnNpbms7XHJcbiAgICAgIHZhciBzb3VyY2UgPSBjb25uZWN0aW9uLnNvdXJjZTtcclxuICAgICAgdmFyIHdlaWdodCA9IGNvbm5lY3Rpb24ud2VpZ2h0O1xyXG4gICAgICBzZWVuTm9kZXMuc2V0KHNpbmssIHNpbmsuZ2V0VmFsdWUoY3JlYXR1cmUpKTtcclxuXHJcbiAgICAgIGlmIChzZWVuTm9kZXMuaGFzKHNvdXJjZSkpIHtcclxuICAgICAgICByZXR1cm4gc2Vlbk5vZGVzLmdldChzb3VyY2UpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZS5jb25uZWN0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAvLyB3ZSdyZSBhdCB0aGUgdG9wIG9mIHRoZSB0cmVlIHNvIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGlucHV0ICogd2VpZ2h0XHJcbiAgICAgICAgdmFyIGlucHV0ID0gc291cmNlLmdldFZhbHVlKGNyZWF0dXJlKTtcclxuICAgICAgICByZXR1cm4gaW5wdXQgKiB3ZWlnaHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gd2Ugc3RpbGwgaGF2ZSBtb3JlIGNvbm5lY3Rpb25zIHRvIGdldFxyXG4gICAgICAgIHZhciBzdW1PZldlaWdodGVkSW5wdXRzID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc291cmNlLmNvbm5lY3Rpb25zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHNvdXJjZS5jb25uZWN0aW9uc1tpbmRleF07XHJcbiAgICAgICAgICBzdW1PZldlaWdodGVkSW5wdXRzICs9IGdldElucHV0KGNvbm5lY3Rpb24sIHNlZW5Ob2Rlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC50YW5oKHN1bU9mV2VpZ2h0ZWRJbnB1dHMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzdW1PZldlaWdodGVkSW5wdXRzID0gMDtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBuZXVyb24uY29ubmVjdGlvbnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IHNlZW5Ob2RlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldXJvbi5jb25uZWN0aW9uc1tpbmRleF07XHJcbiAgICAgIHN1bU9mV2VpZ2h0ZWRJbnB1dHMgKz0gZ2V0SW5wdXQoY29ubmVjdGlvbiwgc2Vlbk5vZGVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLnRhbmgoc3VtT2ZXZWlnaHRlZElucHV0cyk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBDcmVhdHVyZSBmcm9tIFwiLi9jcmVhdHVyZS5qc1wiO1xyXG5pbXBvcnQgR2FtZSBmcm9tIFwiLi9nYW1lLmpzXCI7XHJcbmltcG9ydCBHZW5vbWUgZnJvbSBcIi4vZ2Vub21lLmpzXCI7XHJcbmltcG9ydCBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0IGZyb20gXCIuL25uL2lucHV0cy9TZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0XCI7XHJcbmltcG9ydCBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0IGZyb20gXCIuL25uL2lucHV0cy9TZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0XCI7XHJcbmltcG9ydCBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9Tb3V0aCBmcm9tIFwiLi9ubi9pbnB1dHMvU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvU291dGhcIjtcclxuaW1wb3J0IFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb05vcnRoIGZyb20gXCIuL25uL2lucHV0cy9TZW5zaXRpdml0eVRvUHJveGltaXR5VG9Ob3J0aFwiO1xyXG5pbXBvcnQgTmV1cmFsTmV0d29yayBmcm9tIFwiLi9ubi9uZXVyYWwtbmV0d29yay5qc1wiO1xyXG5cclxuZnVuY3Rpb24gcmFuZG9tTnVtYmVyQmV0d2VlbihtaW4sIG1heCkge1xyXG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByb3VuZFRvTmVhcmVzdChudW1iZXJUb1JvdW5kLCB2YWx1ZVRvTmVhcmVzdCkge1xyXG4gIHJldHVybiBNYXRoLmNlaWwobnVtYmVyVG9Sb3VuZCAvIHZhbHVlVG9OZWFyZXN0KSAqIHZhbHVlVG9OZWFyZXN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbldpdGhpbihnYW1lKSB7XHJcbiAgcmV0dXJuIHJvdW5kVG9OZWFyZXN0KHJhbmRvbU51bWJlckJldHdlZW4oMCwgZ2FtZS53aWR0aCAqIGdhbWUuZGl2aXNpb25TaXplIC0gZ2FtZS5kaXZpc2lvblNpemUpLCBnYW1lLmRpdmlzaW9uU2l6ZSk7XHJcbn1cclxuXHJcbmNvbnN0IHNlbnNpdGl2aXR5TmV1cm9uRmFjdG9yeSA9IChnYW1lKSA9PiAodHlwZSkgPT4ge1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBcIlNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb0Vhc3RcIjpcclxuICAgICAgcmV0dXJuIG5ldyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0KGdhbWUpO1xyXG4gICAgY2FzZSBcIlNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1dlc3RcIjpcclxuICAgICAgcmV0dXJuIG5ldyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0KGdhbWUpO1xyXG4gICAgY2FzZSBcIlNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1NvdXRoXCI6XHJcbiAgICAgIHJldHVybiBuZXcgU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvU291dGgoZ2FtZSk7XHJcbiAgICBjYXNlIFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvTm9ydGhcIjpcclxuICAgICAgcmV0dXJuIG5ldyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9Ob3J0aChnYW1lKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpc2VHYW1lKCkge1xyXG4gIGNvbnN0IGdhbWUgPSBuZXcgR2FtZSgxMjgsIDEyOCwgNSwgZmFsc2UpO1xyXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAxMDsgaW5kZXgrKykge1xyXG4gICAgLy8gMCwwIHRvIDYzNSw2MzVcclxuICAgIGNvbnN0IGdlbm9tZSA9IG5ldyBHZW5vbWUoNSk7XHJcbiAgICBjb25zdCBuZXVyYWxOZXR3b3JrID0gbmV3IE5ldXJhbE5ldHdvcmsoMywgZ2Vub21lLCBzZW5zaXRpdml0eU5ldXJvbkZhY3RvcnkoZ2FtZSkpO1xyXG4gICAgY29uc3QgY3JlYXR1cmUgPSBuZXcgQ3JlYXR1cmUoXHJcbiAgICAgIGdlbm9tZSxcclxuICAgICAgbmV1cmFsTmV0d29yayxcclxuICAgICAgZ2V0UG9zaXRpb25XaXRoaW4oZ2FtZSksXHJcbiAgICAgIGdldFBvc2l0aW9uV2l0aGluKGdhbWUpLFxyXG4gICAgICBnYW1lLmRpdmlzaW9uU2l6ZSxcclxuICAgICAgZ2FtZS53aWR0aCxcclxuICAgICAgZ2FtZS5oZWlnaHQsXHJcbiAgICAgIDEsXHJcbiAgICAgIGZhbHNlXHJcbiAgICApO1xyXG4gICAgZ2FtZS5hZGRDcmVhdHVyZShjcmVhdHVyZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZ2FtZTtcclxufVxyXG5cclxubGV0IGdhbWUgPSBpbml0aWFsaXNlR2FtZSgpO1xyXG5sZXQgZnJhbWVzUGVyU2Vjb25kID0gMzA7XHJcblxyXG5mdW5jdGlvbiBhbmltYXRlKCkge1xyXG4gIGdhbWUudXBkYXRlKCk7XHJcbiAgc2V0VGltZW91dCgoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSksIDEwMDAgLyBmcmFtZXNQZXJTZWNvbmQpO1xyXG59XHJcblxyXG5hbmltYXRlKCk7XHJcblxyXG4vLyB2YXIgbiA9IG5ldyBHZW5vbWUoNCk7XHJcbi8vIG4udG9TdHJpbmcoKTtcclxuXHJcbi8vIHZhciBubiA9IG5ldyBOZXVyYWxOZXR3b3JrKDIpO1xyXG4vLyBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xyXG4vLyAgIHZhciBjb25uZWN0aW9uID0gbm4uZ2V0Q29ubmVjdGlvbihuLmNocm9tb3NvbWVzW2luZGV4XSk7XHJcbi8vICAgY29uc29sZS5sb2coY29ubmVjdGlvbi50b1N0cmluZygpKTtcclxuLy8gfVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')}]);