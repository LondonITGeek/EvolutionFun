!function(n){var c={};function t(i){if(c[i])return c[i].exports;var g=c[i]={i:i,l:!1,exports:{}};return n[i].call(g.exports,g,g.exports,t),g.l=!0,g.exports}t.m=n,t.c=c,t.d=function(n,c,i){t.o(n,c)||Object.defineProperty(n,c,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,c){if(1&c&&(n=t(n)),8&c)return n;if(4&c&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&c&&"string"!=typeof n)for(var g in n)t.d(i,g,function(c){return n[c]}.bind(null,g));return i},t.n=function(n){var c=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(c,"a",c),c},t.o=function(n,c){return Object.prototype.hasOwnProperty.call(n,c)},t.p="",t(t.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/creature.js\nclass Creature {\r\n  // gnome\r\n  // brain\r\n\r\n  constructor(startingX, startingY, dimension, gameWidth, gameHeight, speed, colour, drawInfo) {\r\n    this.gameWidth = gameWidth;\r\n    this.gameHeight = gameHeight;\r\n    this.speed = speed;\r\n    this.colour = colour;\r\n    this.drawInfo = drawInfo;\r\n    this.dimensions = {\r\n      width: dimension,\r\n      height: dimension,\r\n    };\r\n\r\n    this.position = {\r\n      x: startingX,\r\n      y: startingY,\r\n    };\r\n  }\r\n\r\n  drawerLable(ctx) {\r\n    ctx.fillText(`${this.position.x}:${this.position.y}`, this.position.x - 10, this.position.y - 10);\r\n  }\r\n\r\n  drawer(ctx) {\r\n    ctx.fillStyle = this.colour;\r\n    ctx.beginPath();\r\n    ctx.ellipse(\r\n      this.position.x + this.dimensions.width / 2,\r\n      this.position.y + this.dimensions.height / 2,\r\n      this.dimensions.width / 2,\r\n      this.dimensions.height / 2,\r\n      0,\r\n      0,\r\n      2 * Math.PI\r\n    );\r\n    ctx.fill();\r\n    ctx.closePath();\r\n    if (this.drawInfo) {\r\n      this.drawerLable(ctx);\r\n    }\r\n  }\r\n\r\n  update() {\r\n    const currentPosition = {\r\n      ...this.position,\r\n    };\r\n\r\n    switch (Math.floor(Math.random() * 4) + 1) {\r\n      case 1: // right\r\n        this.position.x += this.speed * this.dimensions.width;\r\n        break;\r\n      case 2: // left\r\n        this.position.x -= this.speed * this.dimensions.width;\r\n        break;\r\n      case 3: // up\r\n        this.position.y -= this.speed * this.dimensions.width;\r\n        break;\r\n      case 4: // down\r\n        this.position.y += this.speed * this.dimensions.width;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (\r\n      this.position.x < 0 ||\r\n      this.position.x >= this.gameWidth * this.dimensions.width ||\r\n      this.position.y < 0 ||\r\n      this.position.y >= this.gameHeight * this.dimensions.height\r\n    ) {\r\n      console.log("Hit Edge");\r\n      this.position = currentPosition;\r\n    }\r\n  }\r\n\r\n  updateAndRedrawer(ctx) {\r\n    this.update();\r\n    this.drawer(ctx);\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/game.js\nclass Game {\r\n  constructor(GAME_HEIGHT, GAME_WIDTH, DIVISION_SIZE, SHOW_GRAPH) {\r\n    this.height = GAME_HEIGHT;\r\n    this.width = GAME_WIDTH;\r\n    this.divisionSize = DIVISION_SIZE;\r\n    this.showGraph = SHOW_GRAPH;\r\n    this.gameComponents = [];\r\n\r\n    this.canvas = document.createElement("canvas");\r\n    this.canvas.setAttribute("id", "canvas");\r\n    this.canvas.setAttribute("width", GAME_WIDTH * DIVISION_SIZE);\r\n    this.canvas.setAttribute("height", GAME_HEIGHT * DIVISION_SIZE);\r\n    this.canvas.setAttribute("style", "border: 1px solid black; box-sizing: border-box");\r\n    document.body.appendChild(this.canvas);\r\n    this.ctx = canvas.getContext("2d");\r\n  }\r\n\r\n  addGameComponents(gameComponent) {\r\n    this.gameComponents.push(gameComponent);\r\n  }\r\n\r\n  drawGrid() {\r\n    this.ctx.lineWidth = 0.5;\r\n    // Do columns\r\n    for (let index = this.divisionSize; index < this.width * this.divisionSize; index += this.divisionSize) {\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(index, 0);\r\n      this.ctx.lineTo(index, this.height * this.divisionSize);\r\n      this.ctx.stroke();\r\n      this.ctx.closePath();\r\n    }\r\n\r\n    // Do Rows\r\n    for (let index = this.divisionSize; index < this.height * this.divisionSize; index += this.divisionSize) {\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(0, index);\r\n      this.ctx.lineTo(this.width * this.divisionSize, index);\r\n      this.ctx.stroke();\r\n      this.ctx.closePath();\r\n    }\r\n  }\r\n\r\n  update() {\r\n    this.ctx.fillStyle = "white";\r\n    this.ctx.fillRect(0, 0, this.width * this.divisionSize, this.height * this.divisionSize);\r\n    this.gameComponents.forEach((component) => {\r\n      component.updateAndRedrawer(this.ctx);\r\n    });\r\n\r\n    if (this.showGraph) {\r\n      this.drawGrid();\r\n    }\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/genome.js\nclass Genome {\r\n  constructor(size) {\r\n    // array of 32 bit numbers, each is a link in the brain\r\n    this.chromosomes = new Uint32Array(size);\r\n    window.crypto.getRandomValues(this.chromosomes);\r\n  }\r\n\r\n  toString() {\r\n    this.chromosomes.forEach((c) => {\r\n      console.log(c.toString(2));\r\n    });\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/bit-operations.js\nfunction checkBit(number, bitToCheck) {\r\n  var mask = (1 << bitToCheck) >>> 0;\r\n  var result = (number & mask) >>> 0;\r\n  return result !== 0;\r\n}\r\n\r\nfunction slice(number, start, end) {\r\n  var mask = Math.pow(2, end - start + 1) - 1;\r\n  mask = mask << start;\r\n  var result = number & mask;\r\n  return result >> start;\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/connection.js\nclass Connection {\r\n  constructor(source, sink, weight) {\r\n    this.source = source;\r\n    this.sink = sink;\r\n    this.weight = weight;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.source}:${this.sink}:${this.weight}`;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/neuron.js\nclass Neuron {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.name}`;\r\n  }\r\n}\r\n\r\n// Input (Sensors)\r\n\r\nclass SensitivityToProximityToEast extends Neuron {\r\n  constructor() {\r\n    super("SensitivityToProximityToEast");\r\n  }\r\n}\r\n\r\nclass SensitivityToProximityToWest extends Neuron {\r\n  constructor() {\r\n    super("SensitivityToProximityToWest");\r\n  }\r\n}\r\n\r\nclass SensitivityToProximityToNorth extends Neuron {\r\n  constructor() {\r\n    super("SensitivityToProximityToNorth");\r\n  }\r\n}\r\n\r\nclass SensitivityToProximityToSouth extends Neuron {\r\n  constructor() {\r\n    super("SensitivityToProximityToSouth");\r\n  }\r\n}\r\n\r\n// Outputs (Actions)\r\n\r\nclass GoEast extends Neuron {\r\n  constructor() {\r\n    super("GoEast");\r\n  }\r\n}\r\n\r\nclass GoWest extends Neuron {\r\n  constructor() {\r\n    super("GoWest");\r\n  }\r\n}\r\n\r\nclass GoNorth extends Neuron {\r\n  constructor() {\r\n    super("GoNorth");\r\n  }\r\n}\r\n\r\nclass GoSouth extends Neuron {\r\n  constructor() {\r\n    super("GoSouth");\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/nn/neural-network.js\n\r\n\r\n\r\n\r\nclass neural_network_NeuralNetwork {\r\n  constructor(numberOfHiddenNeurons) {\r\n    this.hiddenNeurons = new Array(numberOfHiddenNeurons);\r\n    for (let index = 0; index < this.hiddenNeurons.length; index++) {\r\n      this.hiddenNeurons[index] = new Neuron(`Hidden Layer ${index}`);\r\n    }\r\n    this.inputNeurons = [\r\n      new SensitivityToProximityToEast(),\r\n      new SensitivityToProximityToNorth(),\r\n      new SensitivityToProximityToSouth(),\r\n      new SensitivityToProximityToWest(),\r\n    ];\r\n    this.outputNeurons = [new GoEast(), new GoNorth(), new GoSouth(), new GoWest()];\r\n  }\r\n\r\n  scaleWeight(weight, xMin, xMax, yMin, yMax) {\r\n    var percent = (weight - yMin) / (yMax - yMin);\r\n    return percent * (xMax - xMin) + xMin;\r\n  }\r\n\r\n  getConnection(chromosome) {\r\n    // first bit is source type (i.e 0 = sensor neuron, or 1 hidden neuron)\r\n    // next 5 bits determine which instance of that source type we have\r\n    // next bit is the sink type (i.e an internal neuron or an action/output neuron)\r\n    // next 20 bits is the weight of the connection\r\n\r\n    //      31| 30-26 | 25| 24-20 |19-----------------0\r\n    //       1| 01110 | 0 | 11000 |10010111001011000101\r\n    //E.g.   0| 00011 | 0 | 01100 |11001100110011001100\r\n    //                             10000000000000000000\r\n    //                             11111111111111111111 = 1048575 - 0\r\n\r\n    var sourceIsAnInputNeuron = checkBit(chromosome, 31); // 0 based index on the bits, i.e. 0 is furthest right (least significant bit)\r\n    var getSourceInstance = slice(chromosome, 26, 30) % (sourceIsAnInputNeuron ? this.inputNeurons.length : this.hiddenNeurons.length);\r\n    var sinkIsAnOutputNeuron = checkBit(chromosome, 25);\r\n    var getOutputInstance = slice(chromosome, 20, 24) % (sinkIsAnOutputNeuron ? this.outputNeurons.length : this.hiddenNeurons.length);\r\n    var weight = this.scaleWeight(slice(chromosome, 0, 19), -4, 4, 0, 1048575);\r\n    var source;\r\n    var sink;\r\n    if (sourceIsAnInputNeuron) {\r\n      // get the sensor type\r\n      source = this.inputNeurons[getSourceInstance];\r\n    } else {\r\n      // this is a hidden layer neuron\r\n      source = this.hiddenNeurons[getSourceInstance];\r\n    }\r\n\r\n    if (sinkIsAnOutputNeuron) {\r\n      // get the action type\r\n      sink = this.outputNeurons[getOutputInstance];\r\n    } else {\r\n      // this is a hidden layer neuron\r\n      sink = this.hiddenNeurons[getOutputInstance];\r\n    }\r\n\r\n    return new Connection(source, sink, weight);\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\n\r\n\r\nfunction getRandomColour() {\r\n  return `#${Math.floor(Math.random() * 16777215).toString(16)}`;\r\n}\r\n\r\nfunction randomNumberBetween(min, max) {\r\n  return Math.floor(Math.random() * (max - min) + 1);\r\n}\r\n\r\nfunction roundToNearest(numberToRound, valueToNearest) {\r\n  return Math.ceil(numberToRound / valueToNearest) * valueToNearest;\r\n}\r\n\r\nfunction getPositionWithin(game) {\r\n  return roundToNearest(randomNumberBetween(0, game.width * game.divisionSize - game.divisionSize), game.divisionSize);\r\n}\r\n\r\nfunction initialiseGame() {\r\n  const game = new Game(128, 128, 5, false);\r\n  const creature = new Creature(\r\n    getPositionWithin(game),\r\n    getPositionWithin(game),\r\n    game.divisionSize,\r\n    game.width,\r\n    game.height,\r\n    1,\r\n    "red",\r\n    true\r\n  );\r\n  game.addGameComponents(creature);\r\n  for (let index = 0; index < 25; index++) {\r\n    // 0,0 to 635,635\r\n    const creature = new Creature(\r\n      getPositionWithin(game),\r\n      getPositionWithin(game),\r\n      game.divisionSize,\r\n      game.width,\r\n      game.height,\r\n      1,\r\n      getRandomColour(),\r\n      false\r\n    );\r\n    game.addGameComponents(creature);\r\n  }\r\n\r\n  return game;\r\n}\r\n\r\nlet src_game = initialiseGame();\r\nlet framesPerSecond = 30;\r\n\r\nfunction animate() {\r\n  src_game.update();\r\n  setTimeout(() => requestAnimationFrame(animate), 1000 / framesPerSecond);\r\n}\r\n\r\nanimate();\r\n\r\nvar n = new Genome(4);\r\nn.toString();\r\n\r\nvar nn = new neural_network_NeuralNetwork(2);\r\nfor (let index = 0; index < 4; index++) {\r\n  var connection = nn.getConnection(n.chromosomes[index]);\r\n  console.log(connection.toString());\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3JlYXR1cmUuanM/MDE0YyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS5qcz83ZGUwIiwid2VicGFjazovLy8uL3NyYy9nZW5vbWUuanM/ZGZjNSIsIndlYnBhY2s6Ly8vLi9zcmMvYml0LW9wZXJhdGlvbnMuanM/YjBlZiIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vY29ubmVjdGlvbi5qcz9iMjc0Iiwid2VicGFjazovLy8uL3NyYy9ubi9uZXVyb24uanM/ZWU0NyIsIndlYnBhY2s6Ly8vLi9zcmMvbm4vbmV1cmFsLW5ldHdvcmsuanM/MDU0OCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pGZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBd0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHlDQUF5QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRGU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUNaTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWGU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxZQUFZLEdBQUcsVUFBVSxHQUFHLFlBQVk7QUFDdEQ7QUFDQTs7O0FDVmU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQzVEb0Q7QUFDZDtBQVVwQjs7QUFFSCxNQUFNLDRCQUFhO0FBQ2xDO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFELHNDQUFzQyxNQUFNLGlCQUFpQixNQUFNO0FBQ25FO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVLDZCQUE2QjtBQUN2QyxVQUFVLDZCQUE2QjtBQUN2QyxVQUFVLDRCQUE0QjtBQUN0QztBQUNBLDhCQUE4QixNQUFNLFFBQVEsT0FBTyxRQUFRLE9BQU8sUUFBUSxNQUFNO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUSxpQkFBaUI7QUFDekQsNEJBQTRCLEtBQUs7QUFDakMsK0JBQStCLFFBQVE7QUFDdkMsNEJBQTRCLEtBQUs7QUFDakMsa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFVBQVU7QUFDekI7QUFDQTs7O0FDdEVxQztBQUNSO0FBQ0k7QUFDa0I7O0FBRW5EO0FBQ0EsYUFBYSxrREFBa0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsSUFBSTtBQUN2Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksUUFBSTtBQUNSOztBQUVBO0FBQ0EsRUFBRSxRQUFJO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxZQUFZLE1BQU07QUFDbEI7O0FBRUEsYUFBYSw0QkFBYTtBQUMxQixtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWF0dXJlIHtcclxuICAvLyBnbm9tZVxyXG4gIC8vIGJyYWluXHJcblxyXG4gIGNvbnN0cnVjdG9yKHN0YXJ0aW5nWCwgc3RhcnRpbmdZLCBkaW1lbnNpb24sIGdhbWVXaWR0aCwgZ2FtZUhlaWdodCwgc3BlZWQsIGNvbG91ciwgZHJhd0luZm8pIHtcclxuICAgIHRoaXMuZ2FtZVdpZHRoID0gZ2FtZVdpZHRoO1xyXG4gICAgdGhpcy5nYW1lSGVpZ2h0ID0gZ2FtZUhlaWdodDtcclxuICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcclxuICAgIHRoaXMuY29sb3VyID0gY29sb3VyO1xyXG4gICAgdGhpcy5kcmF3SW5mbyA9IGRyYXdJbmZvO1xyXG4gICAgdGhpcy5kaW1lbnNpb25zID0ge1xyXG4gICAgICB3aWR0aDogZGltZW5zaW9uLFxyXG4gICAgICBoZWlnaHQ6IGRpbWVuc2lvbixcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHtcclxuICAgICAgeDogc3RhcnRpbmdYLFxyXG4gICAgICB5OiBzdGFydGluZ1ksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZHJhd2VyTGFibGUoY3R4KSB7XHJcbiAgICBjdHguZmlsbFRleHQoYCR7dGhpcy5wb3NpdGlvbi54fToke3RoaXMucG9zaXRpb24ueX1gLCB0aGlzLnBvc2l0aW9uLnggLSAxMCwgdGhpcy5wb3NpdGlvbi55IC0gMTApO1xyXG4gIH1cclxuXHJcbiAgZHJhd2VyKGN0eCkge1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3VyO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmVsbGlwc2UoXHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCArIHRoaXMuZGltZW5zaW9ucy53aWR0aCAvIDIsXHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSArIHRoaXMuZGltZW5zaW9ucy5oZWlnaHQgLyAyLFxyXG4gICAgICB0aGlzLmRpbWVuc2lvbnMud2lkdGggLyAyLFxyXG4gICAgICB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0IC8gMixcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMiAqIE1hdGguUElcclxuICAgICk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgaWYgKHRoaXMuZHJhd0luZm8pIHtcclxuICAgICAgdGhpcy5kcmF3ZXJMYWJsZShjdHgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0ge1xyXG4gICAgICAuLi50aGlzLnBvc2l0aW9uLFxyXG4gICAgfTtcclxuXHJcbiAgICBzd2l0Y2ggKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMSkge1xyXG4gICAgICBjYXNlIDE6IC8vIHJpZ2h0XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHRoaXMuc3BlZWQgKiB0aGlzLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjogLy8gbGVmdFxyXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCAtPSB0aGlzLnNwZWVkICogdGhpcy5kaW1lbnNpb25zLndpZHRoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6IC8vIHVwXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55IC09IHRoaXMuc3BlZWQgKiB0aGlzLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDogLy8gZG93blxyXG4gICAgICAgIHRoaXMucG9zaXRpb24ueSArPSB0aGlzLnNwZWVkICogdGhpcy5kaW1lbnNpb25zLndpZHRoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgdGhpcy5wb3NpdGlvbi54IDwgMCB8fFxyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPj0gdGhpcy5nYW1lV2lkdGggKiB0aGlzLmRpbWVuc2lvbnMud2lkdGggfHxcclxuICAgICAgdGhpcy5wb3NpdGlvbi55IDwgMCB8fFxyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPj0gdGhpcy5nYW1lSGVpZ2h0ICogdGhpcy5kaW1lbnNpb25zLmhlaWdodFxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiSGl0IEVkZ2VcIik7XHJcbiAgICAgIHRoaXMucG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVBbmRSZWRyYXdlcihjdHgpIHtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB0aGlzLmRyYXdlcihjdHgpO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcclxuICBjb25zdHJ1Y3RvcihHQU1FX0hFSUdIVCwgR0FNRV9XSURUSCwgRElWSVNJT05fU0laRSwgU0hPV19HUkFQSCkge1xyXG4gICAgdGhpcy5oZWlnaHQgPSBHQU1FX0hFSUdIVDtcclxuICAgIHRoaXMud2lkdGggPSBHQU1FX1dJRFRIO1xyXG4gICAgdGhpcy5kaXZpc2lvblNpemUgPSBESVZJU0lPTl9TSVpFO1xyXG4gICAgdGhpcy5zaG93R3JhcGggPSBTSE9XX0dSQVBIO1xyXG4gICAgdGhpcy5nYW1lQ29tcG9uZW50cyA9IFtdO1xyXG5cclxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiY2FudmFzXCIpO1xyXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgR0FNRV9XSURUSCAqIERJVklTSU9OX1NJWkUpO1xyXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIEdBTUVfSEVJR0hUICogRElWSVNJT05fU0laRSk7XHJcbiAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImJvcmRlcjogMXB4IHNvbGlkIGJsYWNrOyBib3gtc2l6aW5nOiBib3JkZXItYm94XCIpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XHJcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgfVxyXG5cclxuICBhZGRHYW1lQ29tcG9uZW50cyhnYW1lQ29tcG9uZW50KSB7XHJcbiAgICB0aGlzLmdhbWVDb21wb25lbnRzLnB1c2goZ2FtZUNvbXBvbmVudCk7XHJcbiAgfVxyXG5cclxuICBkcmF3R3JpZCgpIHtcclxuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDAuNTtcclxuICAgIC8vIERvIGNvbHVtbnNcclxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5kaXZpc2lvblNpemU7IGluZGV4IDwgdGhpcy53aWR0aCAqIHRoaXMuZGl2aXNpb25TaXplOyBpbmRleCArPSB0aGlzLmRpdmlzaW9uU2l6ZSkge1xyXG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgdGhpcy5jdHgubW92ZVRvKGluZGV4LCAwKTtcclxuICAgICAgdGhpcy5jdHgubGluZVRvKGluZGV4LCB0aGlzLmhlaWdodCAqIHRoaXMuZGl2aXNpb25TaXplKTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIFJvd3NcclxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5kaXZpc2lvblNpemU7IGluZGV4IDwgdGhpcy5oZWlnaHQgKiB0aGlzLmRpdmlzaW9uU2l6ZTsgaW5kZXggKz0gdGhpcy5kaXZpc2lvblNpemUpIHtcclxuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCBpbmRleCk7XHJcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLndpZHRoICogdGhpcy5kaXZpc2lvblNpemUsIGluZGV4KTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMuZGl2aXNpb25TaXplLCB0aGlzLmhlaWdodCAqIHRoaXMuZGl2aXNpb25TaXplKTtcclxuICAgIHRoaXMuZ2FtZUNvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XHJcbiAgICAgIGNvbXBvbmVudC51cGRhdGVBbmRSZWRyYXdlcih0aGlzLmN0eCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5zaG93R3JhcGgpIHtcclxuICAgICAgdGhpcy5kcmF3R3JpZCgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHZW5vbWUge1xyXG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcclxuICAgIC8vIGFycmF5IG9mIDMyIGJpdCBudW1iZXJzLCBlYWNoIGlzIGEgbGluayBpbiB0aGUgYnJhaW5cclxuICAgIHRoaXMuY2hyb21vc29tZXMgPSBuZXcgVWludDMyQXJyYXkoc2l6ZSk7XHJcbiAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0aGlzLmNocm9tb3NvbWVzKTtcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgdGhpcy5jaHJvbW9zb21lcy5mb3JFYWNoKChjKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGMudG9TdHJpbmcoMikpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBjaGVja0JpdChudW1iZXIsIGJpdFRvQ2hlY2spIHtcclxuICB2YXIgbWFzayA9ICgxIDw8IGJpdFRvQ2hlY2spID4+PiAwO1xyXG4gIHZhciByZXN1bHQgPSAobnVtYmVyICYgbWFzaykgPj4+IDA7XHJcbiAgcmV0dXJuIHJlc3VsdCAhPT0gMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKG51bWJlciwgc3RhcnQsIGVuZCkge1xyXG4gIHZhciBtYXNrID0gTWF0aC5wb3coMiwgZW5kIC0gc3RhcnQgKyAxKSAtIDE7XHJcbiAgbWFzayA9IG1hc2sgPDwgc3RhcnQ7XHJcbiAgdmFyIHJlc3VsdCA9IG51bWJlciAmIG1hc2s7XHJcbiAgcmV0dXJuIHJlc3VsdCA+PiBzdGFydDtcclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0aW9uIHtcclxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNpbmssIHdlaWdodCkge1xyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB0aGlzLnNpbmsgPSBzaW5rO1xyXG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBgJHt0aGlzLnNvdXJjZX06JHt0aGlzLnNpbmt9OiR7dGhpcy53ZWlnaHR9YDtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy5uYW1lfWA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBJbnB1dCAoU2Vuc29ycylcclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0IGV4dGVuZHMgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvRWFzdFwiKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9XZXN0IGV4dGVuZHMgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvV2VzdFwiKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9Ob3J0aCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIlNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb05vcnRoXCIpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1NvdXRoIGV4dGVuZHMgTmV1cm9uIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKFwiU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvU291dGhcIik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBPdXRwdXRzIChBY3Rpb25zKVxyXG5cclxuZXhwb3J0IGNsYXNzIEdvRWFzdCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvRWFzdFwiKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBHb1dlc3QgZXh0ZW5kcyBOZXVyb24ge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoXCJHb1dlc3RcIik7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR29Ob3J0aCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvTm9ydGhcIik7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR29Tb3V0aCBleHRlbmRzIE5ldXJvbiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcihcIkdvU291dGhcIik7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IGNoZWNrQml0LCBzbGljZSB9IGZyb20gXCIuLi9iaXQtb3BlcmF0aW9uc1wiO1xyXG5pbXBvcnQgQ29ubmVjdGlvbiBmcm9tIFwiLi9jb25uZWN0aW9uXCI7XHJcbmltcG9ydCBOZXVyb24sIHtcclxuICBHb0Vhc3QsXHJcbiAgR29Ob3J0aCxcclxuICBHb1NvdXRoLFxyXG4gIEdvV2VzdCxcclxuICBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0LFxyXG4gIFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1NvdXRoLFxyXG4gIFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb05vcnRoLFxyXG4gIFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1dlc3QsXHJcbn0gZnJvbSBcIi4vbmV1cm9uXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXVyYWxOZXR3b3JrIHtcclxuICBjb25zdHJ1Y3RvcihudW1iZXJPZkhpZGRlbk5ldXJvbnMpIHtcclxuICAgIHRoaXMuaGlkZGVuTmV1cm9ucyA9IG5ldyBBcnJheShudW1iZXJPZkhpZGRlbk5ldXJvbnMpO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaGlkZGVuTmV1cm9ucy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgdGhpcy5oaWRkZW5OZXVyb25zW2luZGV4XSA9IG5ldyBOZXVyb24oYEhpZGRlbiBMYXllciAke2luZGV4fWApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbnB1dE5ldXJvbnMgPSBbXHJcbiAgICAgIG5ldyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9FYXN0KCksXHJcbiAgICAgIG5ldyBTZW5zaXRpdml0eVRvUHJveGltaXR5VG9Ob3J0aCgpLFxyXG4gICAgICBuZXcgU2Vuc2l0aXZpdHlUb1Byb3hpbWl0eVRvU291dGgoKSxcclxuICAgICAgbmV3IFNlbnNpdGl2aXR5VG9Qcm94aW1pdHlUb1dlc3QoKSxcclxuICAgIF07XHJcbiAgICB0aGlzLm91dHB1dE5ldXJvbnMgPSBbbmV3IEdvRWFzdCgpLCBuZXcgR29Ob3J0aCgpLCBuZXcgR29Tb3V0aCgpLCBuZXcgR29XZXN0KCldO1xyXG4gIH1cclxuXHJcbiAgc2NhbGVXZWlnaHQod2VpZ2h0LCB4TWluLCB4TWF4LCB5TWluLCB5TWF4KSB7XHJcbiAgICB2YXIgcGVyY2VudCA9ICh3ZWlnaHQgLSB5TWluKSAvICh5TWF4IC0geU1pbik7XHJcbiAgICByZXR1cm4gcGVyY2VudCAqICh4TWF4IC0geE1pbikgKyB4TWluO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29ubmVjdGlvbihjaHJvbW9zb21lKSB7XHJcbiAgICAvLyBmaXJzdCBiaXQgaXMgc291cmNlIHR5cGUgKGkuZSAwID0gc2Vuc29yIG5ldXJvbiwgb3IgMSBoaWRkZW4gbmV1cm9uKVxyXG4gICAgLy8gbmV4dCA1IGJpdHMgZGV0ZXJtaW5lIHdoaWNoIGluc3RhbmNlIG9mIHRoYXQgc291cmNlIHR5cGUgd2UgaGF2ZVxyXG4gICAgLy8gbmV4dCBiaXQgaXMgdGhlIHNpbmsgdHlwZSAoaS5lIGFuIGludGVybmFsIG5ldXJvbiBvciBhbiBhY3Rpb24vb3V0cHV0IG5ldXJvbilcclxuICAgIC8vIG5leHQgMjAgYml0cyBpcyB0aGUgd2VpZ2h0IG9mIHRoZSBjb25uZWN0aW9uXHJcblxyXG4gICAgLy8gICAgICAzMXwgMzAtMjYgfCAyNXwgMjQtMjAgfDE5LS0tLS0tLS0tLS0tLS0tLS0wXHJcbiAgICAvLyAgICAgICAxfCAwMTExMCB8IDAgfCAxMTAwMCB8MTAwMTAxMTEwMDEwMTEwMDAxMDFcclxuICAgIC8vRS5nLiAgIDB8IDAwMDExIHwgMCB8IDAxMTAwIHwxMTAwMTEwMDExMDAxMTAwMTEwMFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMDAwMDAwMDAwMDAwMDAwMDAwXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMTExMTExMTExMTEgPSAxMDQ4NTc1IC0gMFxyXG5cclxuICAgIHZhciBzb3VyY2VJc0FuSW5wdXROZXVyb24gPSBjaGVja0JpdChjaHJvbW9zb21lLCAzMSk7IC8vIDAgYmFzZWQgaW5kZXggb24gdGhlIGJpdHMsIGkuZS4gMCBpcyBmdXJ0aGVzdCByaWdodCAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KVxyXG4gICAgdmFyIGdldFNvdXJjZUluc3RhbmNlID0gc2xpY2UoY2hyb21vc29tZSwgMjYsIDMwKSAlIChzb3VyY2VJc0FuSW5wdXROZXVyb24gPyB0aGlzLmlucHV0TmV1cm9ucy5sZW5ndGggOiB0aGlzLmhpZGRlbk5ldXJvbnMubGVuZ3RoKTtcclxuICAgIHZhciBzaW5rSXNBbk91dHB1dE5ldXJvbiA9IGNoZWNrQml0KGNocm9tb3NvbWUsIDI1KTtcclxuICAgIHZhciBnZXRPdXRwdXRJbnN0YW5jZSA9IHNsaWNlKGNocm9tb3NvbWUsIDIwLCAyNCkgJSAoc2lua0lzQW5PdXRwdXROZXVyb24gPyB0aGlzLm91dHB1dE5ldXJvbnMubGVuZ3RoIDogdGhpcy5oaWRkZW5OZXVyb25zLmxlbmd0aCk7XHJcbiAgICB2YXIgd2VpZ2h0ID0gdGhpcy5zY2FsZVdlaWdodChzbGljZShjaHJvbW9zb21lLCAwLCAxOSksIC00LCA0LCAwLCAxMDQ4NTc1KTtcclxuICAgIHZhciBzb3VyY2U7XHJcbiAgICB2YXIgc2luaztcclxuICAgIGlmIChzb3VyY2VJc0FuSW5wdXROZXVyb24pIHtcclxuICAgICAgLy8gZ2V0IHRoZSBzZW5zb3IgdHlwZVxyXG4gICAgICBzb3VyY2UgPSB0aGlzLmlucHV0TmV1cm9uc1tnZXRTb3VyY2VJbnN0YW5jZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0aGlzIGlzIGEgaGlkZGVuIGxheWVyIG5ldXJvblxyXG4gICAgICBzb3VyY2UgPSB0aGlzLmhpZGRlbk5ldXJvbnNbZ2V0U291cmNlSW5zdGFuY2VdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzaW5rSXNBbk91dHB1dE5ldXJvbikge1xyXG4gICAgICAvLyBnZXQgdGhlIGFjdGlvbiB0eXBlXHJcbiAgICAgIHNpbmsgPSB0aGlzLm91dHB1dE5ldXJvbnNbZ2V0T3V0cHV0SW5zdGFuY2VdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdGhpcyBpcyBhIGhpZGRlbiBsYXllciBuZXVyb25cclxuICAgICAgc2luayA9IHRoaXMuaGlkZGVuTmV1cm9uc1tnZXRPdXRwdXRJbnN0YW5jZV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uKHNvdXJjZSwgc2luaywgd2VpZ2h0KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IENyZWF0dXJlIGZyb20gXCIuL2NyZWF0dXJlLmpzXCI7XHJcbmltcG9ydCBHYW1lIGZyb20gXCIuL2dhbWUuanNcIjtcclxuaW1wb3J0IEdlbm9tZSBmcm9tIFwiLi9nZW5vbWUuanNcIjtcclxuaW1wb3J0IE5ldXJhbE5ldHdvcmsgZnJvbSBcIi4vbm4vbmV1cmFsLW5ldHdvcmsuanNcIjtcclxuXHJcbmZ1bmN0aW9uIGdldFJhbmRvbUNvbG91cigpIHtcclxuICByZXR1cm4gYCMke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE1KS50b1N0cmluZygxNil9YDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tTnVtYmVyQmV0d2VlbihtaW4sIG1heCkge1xyXG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByb3VuZFRvTmVhcmVzdChudW1iZXJUb1JvdW5kLCB2YWx1ZVRvTmVhcmVzdCkge1xyXG4gIHJldHVybiBNYXRoLmNlaWwobnVtYmVyVG9Sb3VuZCAvIHZhbHVlVG9OZWFyZXN0KSAqIHZhbHVlVG9OZWFyZXN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbldpdGhpbihnYW1lKSB7XHJcbiAgcmV0dXJuIHJvdW5kVG9OZWFyZXN0KHJhbmRvbU51bWJlckJldHdlZW4oMCwgZ2FtZS53aWR0aCAqIGdhbWUuZGl2aXNpb25TaXplIC0gZ2FtZS5kaXZpc2lvblNpemUpLCBnYW1lLmRpdmlzaW9uU2l6ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpc2VHYW1lKCkge1xyXG4gIGNvbnN0IGdhbWUgPSBuZXcgR2FtZSgxMjgsIDEyOCwgNSwgZmFsc2UpO1xyXG4gIGNvbnN0IGNyZWF0dXJlID0gbmV3IENyZWF0dXJlKFxyXG4gICAgZ2V0UG9zaXRpb25XaXRoaW4oZ2FtZSksXHJcbiAgICBnZXRQb3NpdGlvbldpdGhpbihnYW1lKSxcclxuICAgIGdhbWUuZGl2aXNpb25TaXplLFxyXG4gICAgZ2FtZS53aWR0aCxcclxuICAgIGdhbWUuaGVpZ2h0LFxyXG4gICAgMSxcclxuICAgIFwicmVkXCIsXHJcbiAgICB0cnVlXHJcbiAgKTtcclxuICBnYW1lLmFkZEdhbWVDb21wb25lbnRzKGNyZWF0dXJlKTtcclxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMjU7IGluZGV4KyspIHtcclxuICAgIC8vIDAsMCB0byA2MzUsNjM1XHJcbiAgICBjb25zdCBjcmVhdHVyZSA9IG5ldyBDcmVhdHVyZShcclxuICAgICAgZ2V0UG9zaXRpb25XaXRoaW4oZ2FtZSksXHJcbiAgICAgIGdldFBvc2l0aW9uV2l0aGluKGdhbWUpLFxyXG4gICAgICBnYW1lLmRpdmlzaW9uU2l6ZSxcclxuICAgICAgZ2FtZS53aWR0aCxcclxuICAgICAgZ2FtZS5oZWlnaHQsXHJcbiAgICAgIDEsXHJcbiAgICAgIGdldFJhbmRvbUNvbG91cigpLFxyXG4gICAgICBmYWxzZVxyXG4gICAgKTtcclxuICAgIGdhbWUuYWRkR2FtZUNvbXBvbmVudHMoY3JlYXR1cmUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdhbWU7XHJcbn1cclxuXHJcbmxldCBnYW1lID0gaW5pdGlhbGlzZUdhbWUoKTtcclxubGV0IGZyYW1lc1BlclNlY29uZCA9IDMwO1xyXG5cclxuZnVuY3Rpb24gYW5pbWF0ZSgpIHtcclxuICBnYW1lLnVwZGF0ZSgpO1xyXG4gIHNldFRpbWVvdXQoKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpLCAxMDAwIC8gZnJhbWVzUGVyU2Vjb25kKTtcclxufVxyXG5cclxuYW5pbWF0ZSgpO1xyXG5cclxudmFyIG4gPSBuZXcgR2Vub21lKDQpO1xyXG5uLnRvU3RyaW5nKCk7XHJcblxyXG52YXIgbm4gPSBuZXcgTmV1cmFsTmV0d29yaygyKTtcclxuZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDQ7IGluZGV4KyspIHtcclxuICB2YXIgY29ubmVjdGlvbiA9IG5uLmdldENvbm5lY3Rpb24obi5jaHJvbW9zb21lc1tpbmRleF0pO1xyXG4gIGNvbnNvbGUubG9nKGNvbm5lY3Rpb24udG9TdHJpbmcoKSk7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')}]);